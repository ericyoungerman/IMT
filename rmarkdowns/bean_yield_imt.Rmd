---
title: "Bean Yield"

output:
  github_document:
    toc: true
always_allow_html: true


---
#Setup
```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo    = TRUE,
  message = FALSE,
  warning = FALSE

)
```
#Packages
```{r}
# Packages ------------------------------------------------------------
library(tidyverse)    # includes dplyr, ggplot2, readr, tibble, etc.
library(janitor)
library(readxl)
library(glmmTMB)
library(DHARMa)
library(emmeans)
library(multcomp)
library(car)
library(kableExtra)
library(here)
library(conflicted)
library(lme4)
library(purrr)
library(tibble)
library(stringr)
library(WrensBookshelf)

# Handle conflicts ----------------------------------------------------
conflicts_prefer(dplyr::select)
conflicts_prefer(dplyr::filter)
conflicts_prefer(dplyr::recode)

# Global theme --------------------------------------------------------
theme_set(theme_bw(base_size = 12))

# Treatment level order (use everywhere) ------------------------------
mow_levels <- c(
  "No mowing",
  "Early mowing",
  "Late mowing",
  "As-needed mowing"
)

# One consistent CVD-safe color palette for all figures ---------------
fill_cols <- WB_brewer(
  name = "BlueberriesForSal",
  n    = length(mow_levels),
  type = "discrete"
) |>
  setNames(mow_levels)

# x-axis label helpers ------------------------------------------------

# Break on spaces (if you ever want every word on its own line)
label_break_spaces <- function(x) {
  stringr::str_replace_all(x, " ", "\n")
}

# Break after the comma: "Rolled,\nno control", etc.
label_break_comma <- function(x) {
  stringr::str_replace_all(x, ", ", ",\n")
}

# Break after comma AND split "high-residue cultivation"
# -> "Rolled,\nhigh-residue\ncultivation"
label_break_comma_cult <- function(x) {
  x |>
    stringr::str_replace("high-residue cultivation",
                         "high-residue\ncultivation") |>
    stringr::str_replace_all(", ", ",\n")
}

# Helper: tidy emmeans output regardless of CI column names -----------
# (works directly on an emmeans object)
# trt_var = name of treatment column to relevel (e.g., "weed_trt", "treatment")

tidy_emm <- function(emm, trt_var = NULL, ref_levels = NULL) {
  emm_df <- as.data.frame(emm)

  lcl_col <- intersect(c("lower.CL", "asymp.LCL"), names(emm_df))[1]
  ucl_col <- intersect(c("upper.CL", "asymp.UCL"), names(emm_df))[1]

  if (is.na(lcl_col) || is.na(ucl_col)) {
    stop("Could not find CI columns in emmeans output.")
  }

  out <- emm_df |>
    dplyr::mutate(
      ci_low  = .data[[lcl_col]],
      ci_high = .data[[ucl_col]]
    )

  if (!is.null(trt_var) && !is.null(ref_levels) && trt_var %in% names(out)) {
    out <- out |>
      dplyr::mutate(
        !!trt_var := factor(.data[[trt_var]], levels = ref_levels)
      )
  }

  out
}


```


# Data import
```{r}
# IMT yield data import & cleaning (2023–2025) -------------------------

# 1) List of raw files (same structure as weed biomass) ----------------
yield_files <- c(
  here("..", "data", "raw", "cornell_raw_2023.xlsx"),
  here("..", "data", "raw", "cornell_raw_2024.xlsx"),
  here("..", "data", "raw", "cornell_raw_2025.xlsx"),
  
  here("..", "data", "raw", "farmhub_raw_2023.xlsx"),
  here("..", "data", "raw", "farmhub_raw_2024.xlsx"),
  here("..", "data", "raw", "farmhub_raw_2025.xlsx"),
  
  here("..", "data", "raw", "maine_raw_2023.xlsx"),
  here("..", "data", "raw", "maine_raw_2024.xlsx"),
  here("..", "data", "raw", "maine_raw_2025.xlsx"),
  
  here("..", "data", "raw", "vermont_raw_2023.xlsx"),
  here("..", "data", "raw", "vermont_raw_2024.xlsx"),
  here("..", "data", "raw", "vermont_raw_2025.xlsx"),
  
  here("..", "data", "raw", "wisconsin_raw_2023.xlsx"),
  here("..", "data", "raw", "wisconsin_raw_2024.xlsx"),
  here("..", "data", "raw", "wisconsin_raw_2025.xlsx")
)

yield_files
file.exists(yield_files)

# 2) Constants for area conversion -------------------------------------
row_spacing_m      <- 0.762   # 30-inch rows
sample_length_m    <- 2       # 2 m of row per sample
sample_area_m2     <- row_spacing_m * sample_length_m
g2m_to_kg_ha       <- 10 / sample_area_m2  # factor to go from g per sample to kg/ha

std_moisture <- 14  # target moisture (%)
# 2) Constants for area conversion -------------------------------------
row_spacing_m      <- 0.762   # 30-inch rows
sample_length_m    <- 2       # 2 m of row per sample
sample_area_m2     <- row_spacing_m * sample_length_m
g2m_to_kg_ha       <- 10 / sample_area_m2  # factor to go from g per sample to kg/ha

std_moisture <- 14  # target moisture (%)

# 3) Robust helper to read + standardize a single yield file -----------

read_yield_file <- function(path) {
  dat <- read_excel(path, na = c("na", "Na", "NA")) |>
    clean_names()
  
  fname <- basename(path)
  
  # Derive location label from filename (used if column is missing)
  loc_label <- dplyr::case_when(
    stringr::str_detect(fname, "cornell")   ~ "Cornell",
    stringr::str_detect(fname, "farmhub")   ~ "FarmHub",
    stringr::str_detect(fname, "maine")     ~ "Maine",
    stringr::str_detect(fname, "vermont")   ~ "Vermont",
    stringr::str_detect(fname, "wisconsin") ~ "Wisconsin",
    TRUE                                    ~ "Unknown"
  )
  
  # Derive year from filename (used if column is missing)
  year_val <- stringr::str_extract(fname, "20[0-9]{2}")
  
  # If location / year columns are missing, create them -----------------
  if (!"location" %in% names(dat)) {
    dat$location <- loc_label
  }
  if (!"year" %in% names(dat)) {
    dat$year <- year_val
  }
  if (!"site_year" %in% names(dat)) {
    dat$site_year <- paste(dat$location, dat$year, sep = "_")
  }
  
  dat |>
    mutate(
      location  = factor(location),
      year      = factor(year),
      site_year = factor(site_year),
      block     = factor(block),
      microplot = stringr::str_trim(microplot),
      
      # Match weed_biomass recode for consistency
      weed_trt  = dplyr::recode(
        treatment,
        "NWC" = "No mowing",
        "EWC" = "Early mowing",
        "LWC" = "Late mowing",
        "AWC" = "As-needed mowing"
      ),
      weed_trt  = factor(weed_trt, levels = mow_levels)
    ) |>
    # use your actual column names:
    # bean_yield = g per 2 m row, percent_moisture = moisture (%)
    rename(
      yield_g_2m   = bean_yield,
      moisture_pct = percent_moisture
    ) |>
    # Moisture adjustment + area conversion -----------------------------
    mutate(
      # If moisture is missing or coded as 0, don't adjust (factor = 1)
      adj_factor_14 = dplyr::if_else(
        is.na(moisture_pct) | moisture_pct == 0,
        1,
        (100 - moisture_pct) / (100 - std_moisture)
      ),
      
      # Adjusted yield to 14% moisture (still g per 2 m)
      yield_g_2m_adj14 = yield_g_2m * adj_factor_14,
      
      # Raw yield and adjusted yield in kg ha^-1
      yield_kg_ha_raw   = yield_g_2m       * g2m_to_kg_ha,
      yield_kg_ha_adj14 = yield_g_2m_adj14 * g2m_to_kg_ha
    )
}

# 4) Read all files and stack ------------------------------------------
imt_yield_clean <- purrr::map_df(yield_files, read_yield_file)


# 5) Quick checks -------------------------------------------------------
kable(
  head(imt_yield_clean),
  caption = "All IMT site-years (2023–2025), cleaned yield with 14% moisture adjustment"
)

imt_yield_clean |>
  count(site_year, weed_trt) |>
  arrange(site_year, weed_trt)

```


## Subsets
```{r}
# Subset for yield models: ambient vs surrogate only -------------------

bean_yield_bi <- imt_yield_clean |>
  mutate(
    weeds = dplyr::recode(
      microplot,
      "M"  = "Ambient weeds",
      "SW" = "Surrogate weeds",
      .default = NA_character_
    ),
    weeds = factor(weeds, levels = c("Ambient weeds", "Surrogate weeds"))
  ) |>
  filter(!is.na(weeds))   # drop weed-free (WF) for this ambient/surrogate analysis

# Quick check: which locations are present? ----------------------------

bean_yield_bi |>
  count(location) |>
  kable(
    caption = "Number of ambient/surrogate yield microplots by location"
  ) |>
  kable_styling(full_width = FALSE)


# Ecobean = all five locations in the IMT network ----------------------

bean_yield_eco <- bean_yield_bi |>
  filter(location %in% c("CU", "FH", "ME", "VT", "WI")) |>
  droplevels()

# New York only = Cornell + Farm Hub -----------------------------------

bean_yield_ny <- bean_yield_bi |>
  filter(location %in% c("CU", "FH")) |>
  droplevels()

# Optional: quick sanity check of site-years in each subset ------------

bean_yield_eco |>
  count(site_year) |>
  kable(
    caption = "Ecobean subset: ambient/surrogate yield microplots by site-year"
  ) |>
  kable_styling(full_width = FALSE)

bean_yield_ny |>
  count(site_year) |>
  kable(
    caption = "NY-only subset: ambient/surrogate yield microplots by site-year"
  ) |>
  kable_styling(full_width = FALSE)

```

# Model testing
## Exploratory 
```{r}
## 1a) Ecobean (all five locations, 2023–2025): bean yield --------------

# Summary table by site-year × mowing
bean_yield_eco |>
  group_by(site_year, weed_trt) |>
  summarise(
    n       = n(),
    mean    = mean(yield_kg_ha_adj14, na.rm = TRUE),
    median  = median(yield_kg_ha_adj14, na.rm = TRUE),
    sd      = sd(yield_kg_ha_adj14, na.rm = TRUE),
    .groups = "drop"
  ) |>
  arrange(site_year, weed_trt) |>
  kable(
    digits  = 1,
    caption = "Ecobean (all locations): bean yield (kg ha\u207b\u00b9, adjusted to 14% moisture) by site-year \u00d7 mowing treatment"
  ) |>
  kable_styling(
    full_width        = FALSE,
    bootstrap_options = c("striped", "hover")
  )

# Boxplot: rows = year (2023–2025), columns = location ------------------
yield_box_eco <- bean_yield_eco |>
  mutate(
    year     = factor(year, levels = c(2023, 2024, 2025)),
    location = factor(location, levels = c("CU", "FH", "ME", "VT", "WI"))
  ) |>
  ggplot(aes(x = weed_trt, y = yield_kg_ha_adj14, fill = weed_trt)) +
  geom_boxplot(
    outlier.shape = NA,
    width         = 0.55,
    color         = "black"
  ) +
  geom_jitter(
    width  = 0.12,
    height = 0,
    alpha  = 0.4,
    size   = 1.8,
    color  = "grey30"
  ) +
  facet_grid(year ~ location) +
  scale_fill_manual(values = fill_cols, guide = "none") +
  scale_x_discrete(labels = label_break_spaces) +
  scale_y_continuous(labels = scales::label_comma()) +
  labs(
    x     = NULL,
    y     = "Bean yield (kg ha\u207b\u00b9, adjusted to 14% moisture)",
    title = "Ecobean: bean yield by mowing treatment (adjusted to 14% moisture)"
  ) +
  theme(
    axis.text.x = element_text(size = 9),
    strip.text  = element_text(face = "bold")
  )

yield_box_eco  # print in the Rmd


## 1b) New York only (Cornell + Farm Hub): bean yield -------------------

# Summary table by site-year × mowing
bean_yield_ny |>
  group_by(site_year, weed_trt) |>
  summarise(
    n       = n(),
    mean    = mean(yield_kg_ha_adj14, na.rm = TRUE),
    median  = median(yield_kg_ha_adj14, na.rm = TRUE),
    sd      = sd(yield_kg_ha_adj14, na.rm = TRUE),
    .groups = "drop"
  ) |>
  arrange(site_year, weed_trt) |>
  kable(
    digits  = 1,
    caption = "New York only (Cornell + Farm Hub): bean yield (kg ha\u207b\u00b9, adjusted to 14% moisture) by site-year \u00d7 mowing treatment"
  ) |>
  kable_styling(
    full_width        = FALSE,
    bootstrap_options = c("striped", "hover")
  )

# Boxplot for NY only, same layout: rows = year, columns = location ----
yield_box_ny <- bean_yield_ny |>
  mutate(
    year     = factor(year, levels = c(2023, 2024, 2025)),
    location = factor(location, levels = c("CU", "FH"))
  ) |>
  ggplot(aes(x = weed_trt, y = yield_kg_ha_adj14, fill = weed_trt)) +
  geom_boxplot(
    outlier.shape = NA,
    width         = 0.55,
    color         = "black"
  ) +
  geom_jitter(
    width  = 0.12,
    height = 0,
    alpha  = 0.4,
    size   = 1.8,
    color  = "grey30"
  ) +
  facet_grid(year ~ location) +
  scale_fill_manual(values = fill_cols, guide = "none") +
  scale_x_discrete(labels = label_break_spaces) +
  scale_y_continuous(labels = scales::label_comma()) +
  labs(
    x     = NULL,
    y     = "Bean yield (kg ha\u207b\u00b9, adjusted to 14% moisture)",
    title = "New York (Cornell + Farm Hub): bean yield by mowing treatment (adjusted to 14% moisture)"
  ) +
  theme(
    axis.text.x = element_text(size = 9),
    strip.text  = element_text(face = "bold")
  )

yield_box_ny  # print in the Rmd


# Figure directories for yield -----------------------------------------
fig_dir_yield_eco <- here("analysis", "figs", "yield", "ecobean")
fig_dir_yield_ny  <- here("analysis", "figs", "yield", "ny-only")

dir.create(fig_dir_yield_eco, showWarnings = FALSE, recursive = TRUE)
dir.create(fig_dir_yield_ny,  showWarnings = FALSE, recursive = TRUE)

# Save Ecobean yield figure --------------------------------------------
ggsave(
  filename = file.path(
    fig_dir_yield_eco,
    "fig_bean_yield_box_ecobean_kg_ha_adj14.png"
  ),
  plot   = yield_box_eco,
  width  = 12,
  height = 6,
  dpi    = 300
)

# Save NY-only yield figure --------------------------------------------
ggsave(
  filename = file.path(
    fig_dir_yield_ny,
    "fig_bean_yield_box_ny_kg_ha_adj14.png"
  ),
  plot   = yield_box_ny,
  width  = 12,
  height = 6,
  dpi    = 300
)

```
## Selection
### Ecobean
```{r}
## Ecobean bean yield (kg ha^-1, adjusted to 14% moisture):
## model testing / selection -------------------------------------------

options(contrasts = c("contr.sum", "contr.poly"))

# 1) Candidate Gaussian LMMs (REML fits used for estimation) -----------

# Interaction model: mowing × weediness + site_year
yield_eco_int <- lmer(
  yield_kg_ha_adj14 ~ weed_trt * weeds + site_year +
    (1 | site_year) +
    (1 | site_year:block) +
    (1 | site_year:block:weed_trt),
  data = bean_yield_eco
)

# Additive model: main effects of mowing + weediness + site_year
yield_eco_add <- lmer(
  yield_kg_ha_adj14 ~ weed_trt + weeds + site_year +
    (1 | site_year) +
    (1 | site_year:block) +
    (1 | site_year:block:weed_trt),
  data = bean_yield_eco
)

# 2) Likelihood-ratio test + ML AIC (anova() refits with REML = FALSE) -

lrt_yield_eco <- anova(yield_eco_add, yield_eco_int)

# ML-based AICs from the anova table
AIC_add_yield_eco  <- lrt_yield_eco$AIC[1]
AIC_int_yield_eco  <- lrt_yield_eco$AIC[2]
deltaAIC_yield_eco <- AIC_add_yield_eco - AIC_int_yield_eco  # > 0 → interaction better

# LRT p-value for weed_trt × weeds interaction
p_int_yield_eco <- lrt_yield_eco$`Pr(>Chisq)`[2]

# 3) Classify evidence for interaction (same rule as biomass) ----------

p_strong_yield_eco    <- 0.01  # strong evidence threshold
p_none_yield_eco      <- 0.20  # essentially no evidence
dAIC_strong_yield_eco <- 4     # substantial AIC improvement

interaction_class_yield_eco <- dplyr::case_when(
  p_int_yield_eco < p_strong_yield_eco |
    deltaAIC_yield_eco >= dAIC_strong_yield_eco ~ "interaction",
  p_int_yield_eco > p_none_yield_eco &
    abs(deltaAIC_yield_eco) < 2                 ~ "additive",
  TRUE                                          ~ "gray_zone"
)

primary_model_name_yield_eco <- dplyr::case_when(
  interaction_class_yield_eco == "interaction" ~
    "Interaction: weed_trt * weeds + site_year",
  TRUE ~
    "Additive: weed_trt + weeds + site_year"
)

primary_model_name_yield_eco
interaction_class_yield_eco
deltaAIC_yield_eco
p_int_yield_eco

# 4) Final Ecobean yield model for emmeans / plots (REML fits) ---------

yield_lmm_eco <- if (interaction_class_yield_eco == "interaction") {
  yield_eco_int
} else {
  yield_eco_add
}

family_structure_yield_eco <- "Gaussian LMM (identity link)"

# 5) AIC table for reporting (using ML AICs from lrt_yield_eco) --------

aic_yield_eco_out <- tibble::tibble(
  model = c(
    "Additive: weed_trt + weeds + site_year",
    "Interaction: weed_trt * weeds + site_year"
  ),
  AIC = c(AIC_add_yield_eco, AIC_int_yield_eco)
) |>
  dplyr::mutate(
    deltaAIC                 = AIC - min(AIC),
    Selected                 = dplyr::if_else(
      model == primary_model_name_yield_eco, "Yes", ""
    ),
    Evidence_for_interaction = interaction_class_yield_eco
  )

kable(
  aic_yield_eco_out,
  digits  = 2,
  caption = "Ecobean bean yield (kg ha\u207b\u00b9, adjusted to 14% moisture): additive vs interaction (Gaussian LMM, ML AIC)"
) |>
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))


## 6) Diagnostics + Type-III tests for chosen Ecobean yield model ------

set.seed(123)
res_yield_eco <- DHARMa::simulateResiduals(yield_lmm_eco)
plot(res_yield_eco)
DHARMa::testDispersion(yield_lmm_eco)
DHARMa::testZeroInflation(yield_lmm_eco)

anova_yield_eco <- car::Anova(yield_lmm_eco, type = 3)
anova_yield_eco

```

```{r}
## Selection
### Bean yield (kg ha⁻¹)

#### Pooled: mixed model for bean yield (kg ha⁻¹) ----------------------

options(contrasts = c("contr.sum", "contr.poly"))

# Fixed: mowing × weeds (ambient vs surrogate) + site_year
# Random: split-plot structure (site_year, block(site_year), mowing within block(site_year))

# Final bean-yield model (use this one downstream)
yield_lmm <- lmer(
  bean_yield_adj_kg_ha ~ weed_trt * weeds2 + site_year +
    (1 | site_year:block) +
    (1 | site_year:block:weed_trt),
  data = bean_yield_bi
)

# Quick model summary
summary(yield_lmm)

## Diagnostics -----------------------------------------------------------

set.seed(123)
res_yield <- DHARMa::simulateResiduals(yield_lmm)
plot(res_yield)
DHARMa::testDispersion(yield_lmm)
DHARMa::testZeroInflation(yield_lmm)

## Type-III tests --------------------------------------------------------

anova_yield <- car::Anova(yield_lmm, type = 3)
anova_yield


```

###New York only

```{r}
## NY-only bean yield (kg ha^-1, adjusted to 14% moisture):
## model testing / selection -------------------------------------------

options(contrasts = c("contr.sum", "contr.poly"))

# 0) (If needed) define NY-only subset from your full bean-yield dataset
# bean_yield_ny <- bean_yield_bi |>
#   dplyr::filter(location %in% c("CU", "FH")) |>
#   droplevels()

# 1) Candidate Gaussian GLMMs (Ecobean-style) --------------------------

# Additive model: main effects of mowing + weediness + site_year
yield_ny_add <- glmmTMB(
  yield_kg_ha_adj14 ~ weed_trt + weeds + site_year +
    (1 | site_year) +
    (1 | site_year:block) +
    (1 | site_year:block:weed_trt),
  family = gaussian(link = "identity"),
  data   = bean_yield_ny
)

# Interaction model: mowing × weediness + site_year
yield_ny_int <- glmmTMB(
  yield_kg_ha_adj14 ~ weed_trt * weeds + site_year +
    (1 | site_year) +
    (1 | site_year:block) +
    (1 | site_year:block:weed_trt),
  family = gaussian(link = "identity"),
  data   = bean_yield_ny
)

# 2) Likelihood-ratio test + ML AIC ------------------------------------

lrt_yield_ny <- anova(yield_ny_add, yield_ny_int)

# ML-based AICs from the anova table
AIC_add_yield_ny  <- lrt_yield_ny$AIC[1]
AIC_int_yield_ny  <- lrt_yield_ny$AIC[2]
deltaAIC_yield_ny <- AIC_add_yield_ny - AIC_int_yield_ny   # > 0 → interaction better

# LRT p-value for weed_trt × weeds interaction
p_int_yield_ny <- lrt_yield_ny$`Pr(>Chisq)`[2]

AIC_add_yield_ny
AIC_int_yield_ny
deltaAIC_yield_ny
p_int_yield_ny

# 3) Classify evidence for interaction (same thresholds as Ecobean) ----

p_strong_yield_ny    <- 0.01  # strong evidence threshold
p_none_yield_ny      <- 0.20  # essentially no evidence
dAIC_strong_yield_ny <- 4     # substantial AIC improvement

interaction_class_yield_ny <- dplyr::case_when(
  p_int_yield_ny < p_strong_yield_ny |
    deltaAIC_yield_ny >= dAIC_strong_yield_ny ~ "interaction",
  p_int_yield_ny > p_none_yield_ny &
    abs(deltaAIC_yield_ny) < 2               ~ "additive",
  TRUE                                       ~ "gray_zone"
)

primary_model_name_yield_ny <- dplyr::case_when(
  interaction_class_yield_ny == "interaction" ~
    "Interaction: weed_trt * weeds + site_year",
  TRUE ~
    "Additive: weed_trt + weeds + site_year"
)

primary_model_name_yield_ny
interaction_class_yield_ny
deltaAIC_yield_ny
p_int_yield_ny

# 4) Final NY-only yield model for emmeans / plots ---------------------

yield_lmm_ny <- if (interaction_class_yield_ny == "interaction") {
  yield_ny_int
} else {
  yield_ny_add
}

family_structure_yield_ny <- "Gaussian GLMM (identity link)"

# 5) AIC table for reporting (using ML AICs from lrt_yield_ny) ---------

aic_yield_ny_out <- tibble::tibble(
  model = c(
    "Additive: weed_trt + weeds + site_year",
    "Interaction: weed_trt * weeds + site_year"
  ),
  AIC = c(AIC_add_yield_ny, AIC_int_yield_ny)
) |>
  dplyr::mutate(
    deltaAIC                 = AIC - min(AIC),
    Selected                 = dplyr::if_else(
      model == primary_model_name_yield_ny, "Yes", ""
    ),
    Evidence_for_interaction = interaction_class_yield_ny
  )

kable(
  aic_yield_ny_out,
  digits  = 2,
  caption = "NY-only bean yield (kg ha\u207b\u00b9, adjusted to 14% moisture): additive vs interaction (Gaussian GLMM, ML AIC)"
) |>
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))


## 6) Diagnostics + Type-III tests for chosen NY-only yield model ------

set.seed(123)
res_yield_ny <- DHARMa::simulateResiduals(yield_lmm_ny)
plot(res_yield_ny)
DHARMa::testDispersion(yield_lmm_ny)
DHARMa::testZeroInflation(yield_lmm_ny)

anova_yield_ny <- car::Anova(yield_lmm_ny, type = 3)
anova_yield_ny

```


```{r}
### Bean yield (kg ha⁻¹) by mowing treatment (no CLDs)
### (ambient + surrogate weed microplots only)

# Estimated marginal means for weed_trt on the response scale (kg/ha)
emm_yield <- emmeans(
  yield_lmm,
  ~ weed_trt
)

# Use your tidy_emm helper to standardize CI columns
emm_yield_df <- tidy_emm(
  emm_yield,
  trt_var    = "weed_trt",
  ref_levels = mow_levels
) |>
  select(weed_trt, emmean, SE, ci_low, ci_high) |>
  mutate(
    across(c(emmean, SE, ci_low, ci_high), ~ round(.x, 1))
  )

emm_yield_df |>
  kable(
    caption   = "Estimated bean yield (kg ha⁻¹) by mowing treatment (ambient + surrogate weeds), with 95% CI from a linear mixed model. Mowing had no significant effect on yield (p = 0.16).",
    col.names = c("Treatment", "Mean", "SE", "Lower CI", "Upper CI")
  ) |>
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))

```
## Equivalence testing
```{r}
## Equivalence testing
### Are mowing treatments "close enough" to the no-mowing control?

# 1) EMMs for bean yield -----------------------------------------------
emm_yield <- emmeans(yield_lmm, ~ weed_trt)

# Name of the control treatment (must match mow_levels exactly)
control_trt <- "No mowing"

# Extract treatment levels from emmGrid
trt_levels <- levels(emm_yield)$weed_trt

# Check the reference actually exists
if (!control_trt %in% trt_levels) {
  stop(
    "control_trt ('", control_trt, "') is not a level of weed_trt.\n",
    "Current levels are: ",
    paste(trt_levels, collapse = ", ")
  )
}

# 2) Define equivalence margin (as % of control yield) -----------------

# Model-based control yield (kg ha⁻¹)
control_mean <- summary(emm_yield) |>
  as_tibble() |>
  dplyr::filter(weed_trt == control_trt) |>
  dplyr::pull(emmean)

margin_pct <- 0.10        # e.g., 0.10 = ±10% of control yield
delta_kg   <- margin_pct * control_mean

# For interpretation: convert margin to bu ac⁻¹ (approx)
kg_per_bu_ac <- 67.25     # ≈ kg ha⁻¹ per 1 bu ac⁻¹ for dry bean (60 lb bu⁻¹)
delta_bu_ac  <- delta_kg / kg_per_bu_ac

cat(
  "Equivalence margin:",
  sprintf("±%.0f kg ha⁻¹ (≈ ±%.1f bu ac⁻¹, %.0f%% of No mowing yield)\n",
          delta_kg, delta_bu_ac, margin_pct * 100)
)

# 3) Contrasts: each treatment vs No mowing ----------------------------
yield_vs_control <- contrast(
  emm_yield,
  method = "trt.vs.ctrl",
  ref    = which(trt_levels == control_trt)
)

# 4) TOST-style equivalence tests via emmeans --------------------------
equiv_yield <- summary(
  yield_vs_control,
  infer  = c(TRUE, TRUE),     # show CI + tests
  level  = 0.90,              # 1 - 2*0.05 for α = 0.05 equivalence
  side   = "equivalence",     # two one-sided tests (TOST)
  delta  = delta_kg,
  adjust = "none"
) |>
  as_tibble() |>
  mutate(
    diff_bu_ac  = estimate / kg_per_bu_ac,
    lower_bu_ac = lower.CL / kg_per_bu_ac,
    upper_bu_ac = upper.CL / kg_per_bu_ac,
    p_equiv     = p.value
  )

# 5) Nicely formatted table for the Rmd --------------------------------
equiv_yield_table <- equiv_yield |>
  transmute(
    Contrast    = contrast,
    diff_kg_ha  = estimate,
    lower_kg_ha = lower.CL,
    upper_kg_ha = upper.CL,
    diff_bu_ac,
    lower_bu_ac,
    upper_bu_ac,
    p_equiv
  ) |>
  mutate(
    across(
      c(diff_kg_ha, lower_kg_ha, upper_kg_ha,
        diff_bu_ac, lower_bu_ac, upper_bu_ac),
      ~ round(.x, 1)
    ),
    p_equiv = signif(p_equiv, 3)
  ) |>
  kable(
    caption = paste0(
      "Equivalence tests for bean yield vs ",
      control_trt,
      " (margin = ±",
      round(delta_kg, 0), " kg ha⁻¹ ≈ ±",
      round(delta_bu_ac, 1), " bu ac⁻¹; ",
      round(margin_pct * 100), "% of control yield)."
    ),
    col.names = c(
      "Contrast",
      "Difference (kg ha⁻¹)", "Lower 90% CI", "Upper 90% CI",
      "Difference (bu ac⁻¹)", "Lower 90% CI", "Upper 90% CI",
      "p (equiv.)"
    )
  ) |>
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))

equiv_yield_table

```
```{r}
## Equivalence testing
### Are other mowing treatments "close enough" to Early mowing?

# 1) EMMs for bean yield -----------------------------------------------
emm_yield <- emmeans(yield_lmm, ~ weed_trt)

# Name of the reference treatment (must match mow_levels exactly)
control_trt <- "Early mowing"

# Extract treatment levels from emmGrid
trt_levels <- levels(emm_yield)$weed_trt

# Check the reference actually exists
if (!control_trt %in% trt_levels) {
  stop(
    "control_trt ('", control_trt, "') is not a level of weed_trt.\n",
    "Current levels are: ",
    paste(trt_levels, collapse = ", ")
  )
}

# 2) Define equivalence margin (as % of Early mowing yield) ------------

# Model-based Early mowing yield (kg ha⁻¹)
control_mean <- summary(emm_yield) |>
  as_tibble() |>
  dplyr::filter(weed_trt == control_trt) |>
  dplyr::pull(emmean)

margin_pct <- 0.10        # e.g., 0.10 = ±10% of Early mowing yield
delta_kg   <- margin_pct * control_mean

# For interpretation: convert margin to bu ac⁻¹ (approx)
kg_per_bu_ac <- 67.25     # ≈ kg ha⁻¹ per 1 bu ac⁻¹ for dry bean (60 lb bu⁻¹)
delta_bu_ac  <- delta_kg / kg_per_bu_ac

cat(
  "Equivalence margin:",
  sprintf("±%.0f kg ha⁻¹ (≈ ±%.1f bu ac⁻¹, %.0f%% of %s yield)\n",
          delta_kg, delta_bu_ac, margin_pct * 100, control_trt)
)

# 3) Contrasts: each treatment vs Early mowing -------------------------
yield_vs_control <- contrast(
  emm_yield,
  method = "trt.vs.ctrl",
  ref    = which(trt_levels == control_trt)
)

# 4) TOST-style equivalence tests via emmeans --------------------------
equiv_yield <- summary(
  yield_vs_control,
  infer  = c(TRUE, TRUE),     # show CI + tests
  level  = 0.90,              # 1 - 2*0.05 for α = 0.05 equivalence
  side   = "equivalence",     # two one-sided tests (TOST)
  delta  = delta_kg,
  adjust = "none"
) |>
  as_tibble() |>
  mutate(
    diff_bu_ac  = estimate / kg_per_bu_ac,
    lower_bu_ac = lower.CL / kg_per_bu_ac,
    upper_bu_ac = upper.CL / kg_per_bu_ac,
    p_equiv     = p.value
  )

# 5) Nicely formatted table for the Rmd --------------------------------
equiv_yield_table <- equiv_yield |>
  transmute(
    Contrast    = contrast,
    diff_kg_ha  = estimate,
    lower_kg_ha = lower.CL,
    upper_kg_ha = upper.CL,
    diff_bu_ac,
    lower_bu_ac,
    upper_bu_ac,
    p_equiv
  ) |>
  mutate(
    across(
      c(diff_kg_ha, lower_kg_ha, upper_kg_ha,
        diff_bu_ac, lower_bu_ac, upper_bu_ac),
      ~ round(.x, 1)
    ),
    p_equiv = signif(p_equiv, 3)
  ) |>
  kable(
    caption = paste0(
      "Equivalence tests for bean yield vs ",
      control_trt,
      " (margin = ±",
      round(delta_kg, 0), " kg ha⁻¹ ≈ ±",
      round(delta_bu_ac, 1), " bu ac⁻¹; ",
      round(margin_pct * 100), "% of ", control_trt, " yield)."
    ),
    col.names = c(
      "Contrast",
      "Difference (kg ha⁻¹)", "Lower 90% CI", "Upper 90% CI",
      "Difference (bu ac⁻¹)", "Lower 90% CI", "Upper 90% CI",
      "p (equiv.)"
    )
  ) |>
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))

equiv_yield_table

```

# Figures
## Pooled
```{r}

#### Raw means (kg ha⁻¹)
### Figure: Bean yield by mowing treatment (raw means ± SE)
### (ambient + surrogate weed microplots only)

# 1) Raw means and SE by treatment --------------------------------------
raw_yield_summary <- bean_yield_bi |>
  group_by(weed_trt) |>
  summarise(
    n    = n(),
    mean = mean(bean_yield_adj_kg_ha, na.rm = TRUE),
    sd   = sd(bean_yield_adj_kg_ha, na.rm = TRUE),
    se   = sd / sqrt(n),
    .groups = "drop"
  ) |>
  mutate(
    weed_trt = factor(weed_trt, levels = mow_levels),
    ymin     = pmax(mean - se, 0),
    ymax     = mean + se
  )

# 2) Plot ---------------------------------------------------------------
ggplot(raw_yield_summary, aes(x = weed_trt, y = mean, fill = weed_trt)) +
  geom_col(width = 0.7, color = "black") +
  geom_errorbar(aes(ymin = ymin, ymax = ymax), width = 0.14) +
  scale_fill_manual(values = fill_cols, guide = "none") +
  scale_x_discrete(labels = label_break_spaces) +
  scale_y_continuous(labels = scales::label_comma()) +
  labs(
    x       = NULL,
    y       = expression(Bean~yield~"(kg"~ha^{-1}*")"),
    title   = "Bean yield by mowing treatment"
    
  ) +
  theme_classic(base_size = 18) +
  theme(
    axis.text.x  = element_text(lineheight = 0.95, margin = margin(t = 8)),
    axis.title.y = element_text(margin = margin(r = 8)),
    plot.title   = element_text(face = "bold"),
    plot.caption = element_text(size = 9, hjust = 0)
  )

# 3) Save figure --------------------------------------------------------
ggsave(
  filename = here("figures", "fig_bean_yield_mowing_pooled_raw.png"),
  width    = 9,
  height   = 5.5,
  dpi      = 300
)

```

